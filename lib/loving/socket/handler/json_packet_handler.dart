import 'dart:convert';
import 'dart:developer';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:loving/loving/data/map_area_notifier.dart';

import '../../../model/game/area_map.dart';
import '../../../model/game/item.dart';
import '../../../model/game/monster.dart';
import '../../../model/packet.dart';
import '../../data/player_notifier.dart';
import '../socket_client.dart';

class JsonPacketHandler {
  final Ref _ref;

  JsonPacketHandler({required Ref ref}) : _ref = ref;

  PlayerNotifier get _playerNotifier => _ref.read(playerProvider.notifier);

  AreaMapNotifier get _areaMapNotifier => _ref.read(areaMapProvider.notifier);

  void handle(SocketClient socket, String msg) {
    final areaMap = _ref.read(areaMapProvider);
    final player = _ref.read(playerProvider);

    try {
      final jsonMsg = json.decode(msg);
      final data = jsonMsg["b"]?["o"];
      if (data == null) return;
      final cmd = data["cmd"];

      switch (cmd) {
        case 'moveToArea':
          _areaMapNotifier.update(
            AreaMap(name: data["areaName"], areaId: data["areaId"].toString()),
          );
          break;

        case 'uotls':
          final unm = data['unm'];
          if ((unm as String).toLowerCase() == player.username.toLowerCase()) {
            _playerNotifier.setMaxHP(data['o']['intHPMax'] as int);
          }
          break;

        case 'initUserDatas':
          for (final i in data['a'] as List) {
            final itemData = i['data'] as Map<String, dynamic>;
            final username = itemData['strUsername'] as String;
            final accessLevel = itemData['intAccessLevel'] as String;
            if (player.username.toLowerCase() == username.toLowerCase()) {
              _playerNotifier.setCharId(itemData['CharID'] as String);
              _playerNotifier.setTotalGold(itemData['intGold'] as double);
            }
          }
          if (socket.isInventoryLoaded == false) {
            socket.addLog(
              message: 'Retrieving inventory and bank...',
              packetSender: PacketSender.client,
            );
            socket.sendPacket(
              '%xt%zm%retrieveInventory%${areaMap.areaId}%${socket.user.id}%',
            );
            socket.isInventoryLoaded = true;
          }
          break;

        case 'loadInventoryBig':
          final List<Item> inventoryItems =
              (data['items'] as List)
                  .map((item) => Item.fromJson(item as Map<String, dynamic>))
                  .toList();
          _playerNotifier.setInventoryItems(inventoryItems);
          socket.addLog(
            message: 'Character load completed.',
            packetSender: PacketSender.server,
          );
          socket.isAllLoaded = true;
          break;
      }
    } catch (e) {
      log('JsonPacketHandler err: $e');
    }
  }

  // generated by Gemini, belum dicoba
  List<Monster> _processMonsterData(Map<String, dynamic> data) {
    // 1. Ekstrak list dari data, pastikan tidak null
    final monBranch = data['monBranch'] as List?;
    final monDef = data['mondef'] as List?;
    final monMap = data['monmap'] as List?;

    // Jika salah satu data penting tidak ada, kembalikan list kosong
    if (monBranch == null || monDef == null || monMap == null) {
      return [];
    }

    // 2. Buat "kamus" untuk pencarian cepat nama dan frame.
    // Ini jauh lebih efisien daripada nested loop.
    final nameMap = {
      for (var def in monDef)
        (def['MonID'] as String): (def['strMonName'] as String),
    };

    final frameMap = {
      for (var map in monMap)
        (map['MonMapID'] as String): (map['strFrame'] as String),
    };

    // 3. Buat list Monster awal dari monBranch
    List<Monster> monsters =
        monBranch
            .map((item) => Monster.fromJson(item as Map<String, dynamic>))
            .toList();

    // 4. "Perbarui" monster dengan nama dan frame menggunakan copyWith
    // Proses ini membuat list baru berdasarkan list sebelumnya
    List<Monster> finalMonsters =
        monsters.map((monster) {
          // Cari nama dan frame di "kamus"
          final newName = nameMap[monster.monId];
          final newFrame = frameMap[monster.monMapId];

          // Buat instance baru dengan data yang diperbarui
          return monster.copyWith(monName: newName, frame: newFrame);
        }).toList();

    return finalMonsters;
  }
}
